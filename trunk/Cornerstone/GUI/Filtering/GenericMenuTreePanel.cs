using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Drawing;
using System.Data;
using System.Text;
using System.Windows.Forms;
using Cornerstone.Database.Tables;
using Cornerstone.GUI.Controls;
using System.Threading;
using Cornerstone.Database;
using Cornerstone.Properties;
using Cornerstone.GUI.Dialogs;

namespace Cornerstone.GUI.Filtering {
    public partial class GenericMenuTreePanel<T> : UserControl, IMenuTreePanel, IFieldDisplaySettingsOwner
        where T : DatabaseTable {

        private Dictionary<DBNode<T>, TreeNode> treeNodeLookup = new Dictionary<DBNode<T>,TreeNode>();
        private HashSet<DBNode<T>> updatingNodes = new HashSet<DBNode<T>>();

        TreeNode previousNode = null;
        Color previousForeColor;
        Color previousBackColor;

        public GenericMenuTreePanel() {
            InitializeComponent();

            ImageList imageList = new ImageList();
            imageList.Images.Add("error", Resources.bullet_error);
            imageList.Images.Add("folder", Resources.folder);
            imageList.Images.Add("filterFolder", Resources.folder_filter);
            imageList.Images.Add("endNode", Resources.bullet_go);
            imageList.Images.Add("filteredItem", Resources.bullet_black);

            treeView.ImageList = imageList;
        }

        #region IFieldDisplaySettingsOwner Members

        [Category("Cornerstone Settings")]
        [Description("Manage the type of database table this control connects to and which fields should be displayed.")]
        public FieldDisplaySettings FieldDisplaySettings {
            get {
                if (_fieldSettings == null) {
                    _fieldSettings = new FieldDisplaySettings();
                    _fieldSettings.Owner = this;
                }

                return _fieldSettings;
            }

            set {
                _fieldSettings = value;
                _fieldSettings.Owner = this;
            }
        } private FieldDisplaySettings _fieldSettings = null;

        public void OnFieldPropertiesChanged() {
            //throw new NotImplementedException();
        }

        #region IMenuTreePanel Members

        public event DBNodeEventHandler SelectedNodeChanged;

        [Browsable(false)]
        public DatabaseManager DBManager {
            get {
                return _dbManager;
            }
            set {
                _dbManager = value;
            }
        } private DatabaseManager _dbManager;

        #endregion


        public IDBMenu Menu {
            get { return _menu; }
            set { 
                _menu = (DBMenu<T>)value;
                RepopulateTree();
            }
        } private DBMenu<T> _menu;

        #endregion

        private static int count = 0;
        private void addNodeButton_Click(object sender, EventArgs e) {
            AddNodePopup popup = new AddNodePopup();
            popup.Table = typeof(T);
            popup.ShowDialog();

            if (popup.CloseState == AddNodePopup.CloseStateEnum.ADD_BASIC) {
                addEmptyNode(popup.AddToRoot);
            } else if (popup.CloseState == AddNodePopup.CloseStateEnum.ADD_DYNAMIC) {
                addDynamicNode(popup.DynamicFilteringField, popup.AddToRoot);
            }
        }

        private void removeNodeButton_Click(object sender, EventArgs e) {
            removeNode();
        }

        private void addEmptyNode(bool forceRoot) {
            if (_menu == null)
                return;

            // build internal node object
            DBNode<T> newNode = new DBNode<T>();
            newNode.Name = "New Node " + count;
            count++;

            // build treenode object (for the UI)
            TreeNode treeNode = createTreeNode(newNode);

            // find the appropriate parent
            TreeNode parentTreeNode = treeView.SelectedNode;
            DBNode<T> parent = parentTreeNode == null ? null : (DBNode<T>)parentTreeNode.Tag;

            while (parentTreeNode != null && (parent.AutoGenerated || parent.DynamicNode)) {
                parentTreeNode = parentTreeNode.Parent;
                parent = parentTreeNode == null ? null : (DBNode<T>)parentTreeNode.Tag;
            }
            
            // add the new node and tree node to the existing heirarchies.
            treeView.BeginUpdate();
            if (parentTreeNode != null && !forceRoot) {
                parent.Children.Add(newNode);
                newNode.Parent = parent;
                
                parentTreeNode.Nodes.Add(treeNode);
                parentTreeNode.Expand();
                setVisualProperties(parentTreeNode);
            }
            else {
                _menu.RootNodes.Add(newNode);
                treeView.Nodes.Add(treeNode);
            }

            treeView.EndUpdate();
        }

        private void addDynamicNode(DBField field, bool forceRoot) {
            if (_menu == null)
                return;

            // build internal node object
            DBNode<T> newNode = new DBNode<T>();
            newNode.Name = field.FriendlyName;
            newNode.BasicFilteringField = field;
            newNode.DynamicNode = true;
            newNode.DBManager = DBManager;
            newNode.UpdateDynamicNode();
            
            count++;

            // build treenode object (for the UI)
            TreeNode treeNode = createTreeNode(newNode);

            // find the appropriate parent
            TreeNode parentTreeNode = treeView.SelectedNode;
            DBNode<T> parent = parentTreeNode == null ? null : (DBNode<T>)parentTreeNode.Tag;

            while (parentTreeNode != null && (parent.AutoGenerated || parent.DynamicNode)) {
                parentTreeNode = parentTreeNode.Parent;
                parent = parentTreeNode == null ? null : (DBNode<T>)parentTreeNode.Tag;
            }

            // add the new node and tree node to the existing heirarchies.
            treeView.BeginUpdate();
            if (parentTreeNode != null && !forceRoot) {
                parent.Children.Add(newNode);
                newNode.Parent = parent;

                parentTreeNode.Nodes.Add(treeNode);
                parentTreeNode.Expand();
                setVisualProperties(parentTreeNode);
            }
            else {
                _menu.RootNodes.Add(newNode);
                treeView.Nodes.Add(treeNode);
            }

            treeView.EndUpdate();
        }

        private void removeNode() {
            if (treeView.SelectedNode != null) {
                DBNode<T> selectedNode = (DBNode<T>)treeView.SelectedNode.Tag;

                if (treeView.SelectedNode.Parent == null) {
                    _menu.RootNodes.Remove(selectedNode);
                    treeView.Nodes.Remove(treeView.SelectedNode);
                }
                else {
                    ((DBNode<T>)treeView.SelectedNode.Parent.Tag).Children.Remove(selectedNode);
                    setVisualProperties(treeView.SelectedNode.Parent);
                    treeView.SelectedNode.Parent.Nodes.Remove(treeView.SelectedNode);
                }

                selectedNode.Delete();
            }
        }

        private void RepopulateTree() {
            if (_menu == null) return;

            // stop drawing and clear tree
            treeView.BeginUpdate();
            treeView.Nodes.Clear();

            // add root nodes. children will be recursively added as well
            foreach (DBNode<T> currNode in _menu.RootNodes) 
                treeView.Nodes.Add(createTreeNode(currNode));
            
            // restrart drawing
            treeView.ExpandAll();
            treeView.EndUpdate();
        }

        private TreeNode createTreeNode(DBNode<T> node) {
            TreeNode treeNode;
            if (treeNodeLookup.ContainsKey(node))
                treeNode = treeNodeLookup[node];
            else {
                treeNode = new TreeNode(node.Name);
                treeNode.Tag = node;
                treeNodeLookup[node] = treeNode;
                node.Modified += new DBNodeEventHandler(nodeModified);
            }

            node.UpdateDynamicNode();

            setVisualProperties(treeNode);
            
            // add any missing children
            foreach (DBNode<T> currSubNode in node.Children) {
                TreeNode child = createTreeNode(currSubNode);
                if (!treeNode.Nodes.Contains(child))
                    treeNode.Nodes.Add(child);
            }

            // if this is a leaf node add all items displayed under this menu item
            updateFilteredItems(treeNode);

            treeNode.Collapse();

            return treeNode;
        }

        private void updateFilteredItems(TreeNode treeNode) {
            DBNode<T> node = treeNode.Tag as DBNode<T>;

            if (node == null)
                return;

            if (updatingNodes.Contains(node))
                return;

            updatingNodes.Add(node);

            // if this is a dynamic node, update the children and remove any that are
            // no longer needed
            if (node.DynamicNode) {
                node.UpdateDynamicNode();
                List<TreeNode> subNodesToRemove = new List<TreeNode>();
                foreach (TreeNode currSubNode in treeNode.Nodes)
                    if (!node.Children.Contains(currSubNode.Tag as DBNode<T>))
                        subNodesToRemove.Add(currSubNode);

                foreach (TreeNode currSubNode in subNodesToRemove)
                    treeNode.Nodes.Remove(currSubNode);

                // add any missing children
                foreach (DBNode<T> currSubNode in node.Children) {
                    TreeNode child = createTreeNode(currSubNode);
                    if (!treeNode.Nodes.Contains(child))
                        treeNode.Nodes.Add(child);
                }
            }

            // get list of subitems
            List<TreeNode> filteredItemsToRemove = new List<TreeNode>();
            foreach (TreeNode currSubNode in treeNode.Nodes) {
                if (currSubNode.Tag is T)
                    filteredItemsToRemove.Add(currSubNode);
            }

            // and get rid of them
            foreach (TreeNode currSubNode in filteredItemsToRemove)
                treeNode.Nodes.Remove(currSubNode);

            // if this is not a root level node, delegate to sub node processing and exit
            if (node.Children.Count > 0) {
                foreach (TreeNode currSubNode in treeNode.Nodes)
                    updateFilteredItems(currSubNode);

                updatingNodes.Remove(node);
                return;
            }

            node.DBManager = DBManager;
            if (node.Children.Count == 0 && node.Filter != null) {
                foreach (T currItem in node.GetFilteredItems()) {
                    TreeNode itemNode = new TreeNode(currItem.ToString());
                    itemNode.Tag = currItem;
                    treeNode.Nodes.Add(itemNode);
                    setVisualProperties(itemNode);

                }
            }

            updatingNodes.Remove(node);
        }

        private void setVisualProperties(TreeNode treeNode) {
            DBNode<T> node = null;
            if (treeNode.Tag is DBNode<T>) {
                node = (DBNode<T>)treeNode.Tag;
                treeNode.Text = node.Name;
            }

            if (node != null && node.Children.Count > 0 && node.Filter != null) {
                treeNode.ImageKey = "filterFolder";
                treeNode.SelectedImageKey = "filterFolder";
            }
            else if (node != null && node.Children.Count > 0) {
                treeNode.ImageKey = "folder";
                treeNode.SelectedImageKey = "folder";
            }
            else if (node != null && node.Filter != null) {
                treeNode.ImageKey = "endNode";
                treeNode.SelectedImageKey = "endNode";
            }
            else if (node != null) {
                treeNode.ImageKey = "error";
                treeNode.SelectedImageKey = "error";
            }
            else {
                treeNode.ImageKey = "filteredItem";
                treeNode.SelectedImageKey = "filteredItem";
            }

            // mark as bold if the node has children
            if (node != null && node.Children.Count > 0)
                treeNode.NodeFont = new Font(treeView.Font.Name, treeView.Font.Size, FontStyle.Bold , treeView.Font.Unit);
            else
                treeNode.NodeFont = new Font(treeView.Font.Name, treeView.Font.Size, FontStyle.Regular, treeView.Font.Unit);

            // mark a node in red if it has no children and no filters attached
            // mark a node teal if it has children and a filter attaches as a 
            // visual reminder that the node will be doing some filtering
            if (node != null && node.Children.Count == 0 && node.Filter == null)
                treeNode.ForeColor = Color.Red;
            else if (node != null && node.DynamicNode)
                treeNode.ForeColor = Color.Teal;
            else if (treeNode.Tag is T)
                treeNode.ForeColor = Color.DarkGray;
            else
                treeNode.ForeColor = treeView.ForeColor;
        }

        private void updateButtonStates() {
            DBNode<T> node = null;
            if (treeView.SelectedNode.Tag is DBNode<T>) 
                node = (DBNode<T>)treeView.SelectedNode.Tag;

            if (node == null || node.AutoGenerated) {
                addNodeButton.Enabled = false;
                removeNodeButton.Enabled = false;
                convertToRegularMenuItemButton.Enabled = false;
            }
            else if (node.DynamicNode) {
                addNodeButton.Enabled = true;
                removeNodeButton.Enabled = true;
                convertToRegularMenuItemButton.Enabled = true;
            }
            else {
                addNodeButton.Enabled = true;
                removeNodeButton.Enabled = true;
                convertToRegularMenuItemButton.Enabled = false;
            }
        }

        void nodeModified(IDBNode node, Type type) {
            if (treeNodeLookup.ContainsKey((DBNode<T>)node) && this.Visible) {
                setVisualProperties(treeNodeLookup[(DBNode<T>)node]);
                updateFilteredItems(treeNodeLookup[(DBNode<T>)node]);
            }
        }

        private void treeView_ItemDrag(object sender, ItemDragEventArgs e) {
            TreeNode node = e.Item as TreeNode;

            if (node != null && node.Tag is DBNode<T> && !((DBNode<T>)node.Tag).AutoGenerated) {
                DoDragDrop(e.Item, DragDropEffects.Move);
            }
        }

        private void treeView_DragDrop(object sender, DragEventArgs e) {
            // reset highlight color for last highlighted node
            if (previousNode != null) {
                previousNode.ForeColor = previousForeColor;
                previousNode.BackColor = previousBackColor;
            }

            // grab the item being moved
            TreeNode movedNode = (TreeNode)e.Data.GetData(typeof(TreeNode));
            if (movedNode == null) return;

            // grab the new parent node
            Point pt = treeView.PointToClient(new Point(e.X, e.Y));
            TreeNode newParent = treeView.GetNodeAt(pt);

            // grab the old parent
            TreeNode oldParent = movedNode.Parent;

            if (oldParent == newParent || newParent == movedNode)
                return;

            // remove from old parent node
            if (oldParent != null) {
                oldParent.Nodes.Remove(movedNode);
                ((DBNode<T>)oldParent.Tag).Children.Remove((DBNode<T>)movedNode.Tag);
                setVisualProperties(oldParent);
            }
            // or remove from treeview root if necessary
            else {
                treeView.Nodes.Remove(movedNode);
                _menu.RootNodes.Remove((DBNode<T>)movedNode.Tag);
            }


            // move to the root
            if (newParent == null) {
                treeView.Nodes.Add(movedNode);
                _menu.RootNodes.Add((DBNode<T>)movedNode.Tag);
                ((DBNode<T>)movedNode.Tag).Parent = null;
            }
            // or move to new node if necessary
            else {
                newParent.Nodes.Add(movedNode);
                ((DBNode<T>)newParent.Tag).Children.Add((DBNode<T>)movedNode.Tag);
                ((DBNode<T>)movedNode.Tag).Parent = (DBNode<T>)newParent.Tag;
                setVisualProperties(newParent);
                updateFilteredItems(newParent);
            }

            setVisualProperties(movedNode);
            updateFilteredItems(movedNode);
        }

        private void treeView_DragOver(object sender, DragEventArgs e) {
            // grab the node currently being hovered over
            Point pt = treeView.PointToClient(new Point(e.X, e.Y));
            TreeNode newParent = treeView.GetNodeAt(pt);

            // grab the item being moved
            TreeNode selectedNode = (TreeNode)e.Data.GetData(typeof(TreeNode));
            if (selectedNode == null) return;

            // if hovering over itself a child, or own parent, dont accept drops
            if (newParent == selectedNode || newParent == selectedNode.Parent || isChild(selectedNode, newParent)) {
                e.Effect = DragDropEffects.None;

                // reset previous node highlight color
                if (previousNode != null) {
                    previousNode.ForeColor = previousForeColor;
                    previousNode.BackColor = previousBackColor;
                }

                return;
            }
            else
                e.Effect = DragDropEffects.Move;

            // reset previous node highlight color
            if (previousNode != null && previousNode != newParent) {
                previousNode.ForeColor = previousForeColor;
                previousNode.BackColor = previousBackColor;
            }

            // store reversion settings and highlight the node currently hovering over
            if (newParent != null && previousNode != newParent) {
                previousNode = newParent;
                previousForeColor = newParent.ForeColor;
                previousBackColor = newParent.BackColor;
                newParent.BackColor = SystemColors.Highlight;
                newParent.ForeColor = SystemColors.HighlightText;

            }

        }

        private void treeView_DragEnter(object sender, DragEventArgs e) {
            e.Effect = DragDropEffects.Move;
        }

        private bool isChild(TreeNode parent, TreeNode child) {
            foreach (TreeNode currNode in parent.Nodes) {
                if (currNode == child)
                    return true;

                if (isChild(currNode, child))
                    return true;
            }

            return false;
        }

        private void treeView_AfterLabelEdit(object sender, NodeLabelEditEventArgs e) {
            if (e.CancelEdit || e.Label == null)
                return;

            ((DBNode<T>)treeView.SelectedNode.Tag).Name = e.Label;
        }

        private void treeView_KeyDown(object sender, KeyEventArgs e) {
            if (e.KeyCode == Keys.F2) {
                treeView.SelectedNode.BeginEdit();
            }
            else if (e.KeyCode == Keys.Delete) {
                removeNode();
            }
        }

        private void treeView_AfterSelect(object sender, TreeViewEventArgs e) {
            if (treeView.SelectedNode.Tag is DBNode<T>) {
                if (SelectedNodeChanged != null)
                    SelectedNodeChanged((IDBNode)treeView.SelectedNode.Tag, typeof(T));
            }

            updateButtonStates();
        }

        private void treeView_BeforeLabelEdit(object sender, NodeLabelEditEventArgs e) {
            if (treeView.SelectedNode.Tag is T) {
                e.CancelEdit = true;
            }
        }

        private void convertToRegularMenuItemToolStripMenuItem_Click(object sender, EventArgs e) {            
            if (treeView.SelectedNode == null || !(treeView.SelectedNode.Tag is DBNode<T>)) 
                return;

            DBNode<T> node = treeView.SelectedNode.Tag as DBNode<T>;
            if (!node.DynamicNode)
                return;

            DialogResult result = MessageBox.Show("This will permanently change this dynamic menu item\n" +
                            "to a standard menu item. This means sub elements will no\n" +
                            "longer be automatically generated. This also means you\n" +
                            "can manually modify the menu items.\n\n" +
                            "Do you want to continue?", "Change to Normal Menu Item?", MessageBoxButtons.YesNo);

            if (result == DialogResult.No)
                return;

            node.DynamicNode = false;
            setVisualProperties(treeNodeLookup[node]);

            foreach (DBNode<T> currSubNode in node.Children) {
                currSubNode.AutoGenerated = false;
                setVisualProperties(treeNodeLookup[currSubNode]);
            }
        }

        private void advancedButton_ButtonClick(object sender, EventArgs e) {
            advancedButton.ShowDropDown();
        }

        private void treeView_BeforeSelect(object sender, TreeViewCancelEventArgs e) {
            if (e.Node.Tag is T) {
                if (SelectedNodeChanged != null)
                    SelectedNodeChanged(null, typeof(T));
            }
        }       
    }

    public interface IMenuTreePanel {
        event DBNodeEventHandler SelectedNodeChanged;

        IDBMenu Menu {
            get;
            set;
        }

        DatabaseManager DBManager {
            get;
            set;
        }
    }
}
